from __future__ import annotations
from typing import Protocol, runtime_checkable, Any, Union, overload, TYPE_CHECKING
import numpy as np
import numpy.typing as npt

# Опционально типизируем CuPy массивы, не ломая типизацию если cupy не установлен
if TYPE_CHECKING:
    import cupy as cp
    CuArray = cp.ndarray
else:
    class _Dummy:  # подстановка на случай отсутствия cupy
        pass
    CuArray = _Dummy  # type: ignore[misc,assignment]

Array = Union[npt.NDArray[np.generic], "CuArray"]


@runtime_checkable
class XP(Protocol):
    """Подмножество NumPy/CuPy API, которое реально используешь в коде."""
    # константы/атрибуты
    pi: float

    # создание/преобразование
    def array(self, obj: Any, dtype: Any | None = None) -> Array: ...
    def ndarray(self, obj: Any, dtype: Any | None = None) -> Array: ...
    def asarray(self, obj: Any, dtype: Any | None = None) -> Array: ...
    def zeros_like(self, a: Array, dtype: Any | None = None) -> Array: ...
    def ones_like(self, a: Array, dtype: Any | None = None) -> Array: ...

    # elementwise
    def abs(self, x: Array) -> Array: ...
    def exp(self, x: Array) -> Array: ...
    def sqrt(self, x: Array) -> Array: ...
    def real(self, x: Array) -> Array: ...
    def imag(self, x: Array) -> Array: ...
    def conj(self, x: Array) -> Array: ...
    def log(self, x: Array) -> Array: ...
    def unwrap(self, x: Array) -> Array: ...
    def angle(self, x: Array) -> Array: ...
    def gradient(self, f: Array, *args) -> Array: ...

    # редукции
    def sum(self, x: Array, axis: int | None = None) -> Any: ...
    def max(self, x: Array, axis: int | None = None) -> Any: ...
    def min(self, x: Array, axis: int | None = None) -> Any: ...

    # арифметика (достаточно наличия ufunc’ов — типчики не детализируем)
    def __getattr__(self, name: str) -> Any: ...


class FFTBackend(Protocol):
    xp: XP  # numpy или cupy
    def fft(self, a): ...
    def ifft(self, a): ...
    def fftfreq(self, n: int, d: float): ...
    def fftshift(self, x): ...